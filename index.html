<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WI Ironworker Jurisdictions</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map{height:100%;margin:0}
    .panel{
      position:absolute;top:10px;left:10px;z-index:1000;background:#fff;
      padding:8px 10px;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.2);
      font:14px system-ui,sans-serif;display:flex;gap:6px;flex-wrap:wrap;align-items:center
    }
    .panel input{width:260px;max-width:48vw}
    .legend{
      position:absolute;bottom:10px;left:10px;z-index:1000;background:#fff;
      padding:8px 10px;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.2);
      font:13px system-ui,sans-serif;line-height:1.3
    }
    .sw{display:inline-block;width:12px;height:12px;margin-right:6px;border-radius:3px;vertical-align:middle}
  </style>
</head>
<body>
  <div class="panel">
    <input id="from" placeholder="From address or lat,lng" />
    <input id="to"   placeholder="To address or lat,lng (optional)" />
    <button id="routeBtn">Route</button>
    <span id="msg" style="font-weight:600"></span>
  </div>
  <div id="map"></div>
  <div id="legend" class="legend"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
  // ---------- config ----------
  const GEOJSON_URL = 'jurisdictions.json';
  const GEOAPIFY_KEY = '66dd3a5b023f4dc6bbe5b8dac54b3a00';  // <-- put your key here
  // Bounding box filter for WI + UP (minLon,minLat,maxLon,maxLat)
  const GEOCODE_RECT = [-92.9, 41.5, -83.3, 48.6];

  const COLORS = {
    'Local 498':'#4186f0',
    'Local 383':'#f57c00',
    'Local 8 Southern':'#795548',
    'Local 498 Eastern Zone':'#0ba9cc',
    'Local 8 Northern':'#c2185b',
    'Local 8 Upper Peninsula':'#ffea00',
    'Local 512 A':'#9c27b0',
    'Local 512 B':'#006064'
  };

  let map, zones, zoneLayer, routeLayer, markers = [];

  (async function init(){
    map = L.map('map', { zoomControl: false }).setView([43.8, -89.8], 7);
    L.control.zoom({ position: 'topright' }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Load + draw zones
    zones = await (await fetch(GEOJSON_URL)).json();
    zoneLayer = L.geoJSON(zones, {
      style: f => ({
        color: '#2c3e50', weight: 1,
        fillColor: COLORS[labelFor(f)] || '#467fd0', fillOpacity: 0.18
      }),
      onEachFeature: (f, layer) => {
        layer.on('mouseover', () => layer.setStyle({weight:2, fillOpacity:0.28}));
        layer.on('mouseout',  () => layer.setStyle({weight:1, fillOpacity:0.18}));
        layer.on('click', () => setMsg(`Zone: ${labelFor(f)}`));
      }
    }).addTo(map);
    map.fitBounds(zoneLayer.getBounds());

    // Click anywhere => which zone?
    map.on('click', e => {
      const zone = findZoneName(e.latlng.lat, e.latlng.lng);
      setMsg(zone ? `Zone: ${zone}` : 'Outside all zones');
    });

    // Legend (sorted: Local # then suffix)
    function parseLocal(name){
      const m = name.match(/Local\s+(\d+)\s*(.*)/i);
      return { num: m ? parseInt(m[1], 10) : Infinity, suffix: (m && m[2] || '').trim() };
    }
    const legend = document.getElementById('legend');
    const names = Object.keys(COLORS).sort((a, b) => {
      const A = parseLocal(a), B = parseLocal(b);
      return A.num === B.num ? A.suffix.localeCompare(B.suffix) : A.num - B.num;
    });
    legend.innerHTML = names
      .map(n => `<div><span class="sw" style="background:${COLORS[n]}"></span>${n}</div>`)
      .join('');

    document.getElementById('routeBtn').onclick = checkOrRoute;
  })();

  // ---------- helpers ----------
  function labelFor(f){ const p = f.properties || {}; return p.local || p.name || 'Unknown'; }
  function setMsg(t){ document.getElementById('msg').textContent = t; }

  function findZoneName(lat, lng){
    const pt = turf.point([lng, lat]);
    const hit = zones.features.find(f => turf.booleanPointInPolygon(pt, f));
    return hit ? labelFor(hit) : null;
  }

  function dropMarker(latlng, tag=null){
    const zone = findZoneName(latlng.lat, latlng.lng);
    const text = tag ? `${tag}: ${zone || 'Outside all zones'}` : `Zone: ${zone || 'Outside all zones'}`;
    const m = L.marker(latlng).addTo(map).bindPopup(text).openPopup();
    markers.push(m);
    setMsg(text);
    return zone || 'Outside all zones';
  }

  // ---- check single point OR route with two points ----
  async function checkOrRoute(){
    clearRoute();
    const aTxt = document.getElementById('from').value.trim();
    const bTxt = document.getElementById('to').value.trim();

    if (!aTxt && !bTxt) { setMsg('Enter at least one address'); return; }

    // Single-address mode
    if (!!aTxt ^ !!bTxt) {
      const P = await toLatLng(aTxt || bTxt);
      if (!P) { setMsg('Could not geocode the input'); return; }
      dropMarker(P);
      map.setView(P, Math.max(map.getZoom(), 11));
      return;
    }

    // Two-address routing
    const A = await toLatLng(aTxt);
    const B = await toLatLng(bTxt);
    if (!A || !B) { setMsg('Could not geocode one of the inputs'); return; }

    const zoneA = dropMarker(A, 'A');
    const zoneB = dropMarker(B, 'B');

    // Try lat,lon first (your working setup), then auto-fallback to lon,lat if needed
    let waypoints = `${A.lat},${A.lng}|${B.lat},${B.lng}`;
    let url = `https://api.geoapify.com/v1/routing?waypoints=${encodeURIComponent(waypoints)}&mode=drive&format=geojson&apiKey=${GEOAPIFY_KEY}`;

    let gj = await fetch(url).then(r => r.json().then(j => ({ok: r.ok, j})));
    if (!gj.ok || gj.j.type !== 'FeatureCollection') {
      // fallback in case the API expects lon,lat
      waypoints = `${A.lng},${A.lat}|${B.lng},${B.lat}`;
      url = `https://api.geoapify.com/v1/routing?waypoints=${encodeURIComponent(waypoints)}&mode=drive&format=geojson&apiKey=${GEOAPIFY_KEY}`;
      gj = await fetch(url).then(r => r.json().then(j => ({ok: r.ok, j})));
    }

    if (!gj.ok || gj.j.type !== 'FeatureCollection' || !Array.isArray(gj.j.features)) {
      console.error('Routing response:', gj.j);
      setMsg('Routing error: ' + (gj.j?.message || gj.j?.error || 'unknown'));
      return;
    }

    routeLayer = L.geoJSON(gj.j, { style: { color:'#0066ff', weight:4, opacity:0.9 } }).addTo(map);
    map.fitBounds(routeLayer.getBounds(), { padding:[20,20] });
    setMsg(`Route drawn · A: ${zoneA} · B: ${zoneB}`);
  }

  // Geocode: accepts "lat,lng" or address; uses rect filter with fallback
  async function toLatLng(text){
    const m = text.match(/^\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/);
    if (m) return { lat: parseFloat(m[1]), lng: parseFloat(m[3]) };

    const base = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(text)}&limit=1&apiKey=${GEOAPIFY_KEY}`;
    const withRect = `${base}&filter=rect:${GEOCODE_RECT.join(',')}`;

    // Try with rect filter first
    let r = await fetch(withRect);
    let j = await r.json().catch(()=>null);
    if (!r.ok || !j?.features?.length) {
      // Fallback: no filter (avoids 400s from strict filters)
      r = await fetch(base);
      j = await r.json().catch(()=>null);
      if (!r.ok || !j?.features?.length) return null;
    }
    const [lon, lat] = j.features[0].geometry.coordinates;
    return { lat, lng: lon };
  }

  function clearRoute(){
    if (routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
    markers.forEach(m => map.removeLayer(m)); markers = [];
    setMsg('');
  }
  </script>
</body>
</html>
