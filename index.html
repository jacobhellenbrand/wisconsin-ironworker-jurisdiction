<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WI Ironworker Jurisdictions</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html,body,#map{height:100%;margin:0}
    .panel{
      position:absolute;top:10px;left:10px;z-index:1000;background:#fff;
      padding:8px 10px;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.2);
      font:14px system-ui,sans-serif;display:flex;gap:6px;flex-wrap:wrap;align-items:center
    }
    .panel input{width:260px;max-width:48vw}
    .legend{
      position:absolute;bottom:10px;left:10px;z-index:1000;background:#fff;
      padding:8px 10px;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.2);
      font:13px system-ui,sans-serif;line-height:1.3
    }
    .sw{display:inline-block;width:12px;height:12px;margin-right:6px;border-radius:3px;vertical-align:middle}
  </style>
</head>
<body>
  <div class="panel">
    <input id="from" placeholder="From address or lat,lng" />
    <input id="to"   placeholder="To address or lat,lng (optional)" />
    <button id="routeBtn">Route</button>
    <span id="msg" style="font-weight:600"></span>
  </div>
  <div id="map"></div>
  <div id="legend" class="legend"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
  // ---------- config ----------
  const GEOJSON_URL = 'jurisdictions.json';      // your file
  const GEOAPIFY_KEY = '66dd3a5b023f4dc6bbe5b8dac54b3a00';      // <-- put your key here
  const COLORS = {                               // color per zone (edit names to match your data)
    'Local 498':'#4186f0',
    'Local 383':'#f57c00',
    'Local 8 Southern':'#795548',
    'Local 498 Eastern Zone':'#0ba9cc',
    'Local 8 Northern':'#c2185b',
    'Local 8 Upper Peninsula':'#ffea00',
    'Local 512 A':'#9c27b0',
    'Local 512 B':'#006064'
  };

  let map, zones, zoneLayer, routeLayer, markers = [];

  (async function init(){
    // Map & controls
    map = L.map('map', { zoomControl: false }).setView([43.8, -89.8], 7);
    L.control.zoom({ position: 'topright' }).addTo(map);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 20, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // Load and draw zones
    zones = await (await fetch(GEOJSON_URL)).json();
    zoneLayer = L.geoJSON(zones, {
      style: f => ({
        color: '#2c3e50', weight: 1,
        fillColor: COLORS[labelFor(f)] || '#467fd0', fillOpacity: 0.18
      }),
      onEachFeature: (f, layer) => {
        layer.on('mouseover', () => layer.setStyle({weight:2, fillOpacity:0.28}));
        layer.on('mouseout',  () => layer.setStyle({weight:1, fillOpacity:0.18}));
        layer.on('click', () => setMsg(`Zone: ${labelFor(f)}`));
      }
    }).addTo(map);
    map.fitBounds(zoneLayer.getBounds());

    // Click anywhere → which zone?
    map.on('click', e => {
      const zone = findZoneName(e.latlng.lat, e.latlng.lng);
      setMsg(zone ? `Zone: ${zone}` : 'Outside all zones');
    });

    // Legend (sorted by Local number then suffix)
    function parseLocal(name){
      const m = name.match(/Local\s+(\d+)\s*(.*)/i);
      return { num: m ? parseInt(m[1], 10) : Infinity, suffix: (m && m[2] || '').trim() };
    }
    const legend = document.getElementById('legend');
    const names = Object.keys(COLORS).sort((a, b) => {
      const A = parseLocal(a), B = parseLocal(b);
      return A.num === B.num ? A.suffix.localeCompare(B.suffix) : A.num - B.num;
    });
    legend.innerHTML = names
      .map(n => `<div><span class="sw" style="background:${COLORS[n]}"></span>${n}</div>`)
      .join('');

    // Button
    document.getElementById('routeBtn').onclick = checkOrRoute;
  })();

  // ---------- helpers ----------
  function labelFor(f){
    const p = f.properties || {};
    return p.local || p.name || 'Unknown';
  }
  function setMsg(t){ document.getElementById('msg').textContent = t; }

  function findZoneName(lat, lng){
    const pt = turf.point([lng, lat]);
    const hit = zones.features.find(f => turf.booleanPointInPolygon(pt, f));
    return hit ? labelFor(hit) : null;
  }

  function dropMarker(latlng, tag=null){
    const zone = findZoneName(latlng.lat, latlng.lng);
    const text = tag ? `${tag}: ${zone || 'Outside all zones'}` : `Zone: ${zone || 'Outside all zones'}`;
    const m = L.marker(latlng).addTo(map).bindPopup(text).openPopup();
    markers.push(m);
    setMsg(text);
    return zone || 'Outside all zones';
  }

  // ---- routing / single-point check with Geoapify ----
  async function checkOrRoute(){
    clearRoute();
    const aTxt = document.getElementById('from').value.trim();
    const bTxt = document.getElementById('to').value.trim();

    if (!aTxt && !bTxt) { setMsg('Enter at least one address'); return; }

    // Single-address mode
    if (!!aTxt ^ !!bTxt) {
      const P = await toLatLng(aTxt || bTxt);
      if (!P) { setMsg('Could not geocode the input'); return; }
      dropMarker(P); // popup shows zone name
      map.setView(P, Math.max(map.getZoom(), 11));
      return;
    }

    // Two-address routing
    const A = await toLatLng(aTxt);
    const B = await toLatLng(bTxt);
    if (!A || !B) { setMsg('Could not geocode one of the inputs'); return; }

    const zoneA = dropMarker(A, 'A');
    const zoneB = dropMarker(B, 'B');

    // Geoapify expects "lon,lat|lon,lat"
    const waypoints = `${A.lat},${A.lng}|${B.lat},${B.lng}`;
    const url = `https://api.geoapify.com/v1/routing?waypoints=${encodeURIComponent(waypoints)}&mode=drive&format=geojson&apiKey=${GEOAPIFY_KEY}`;

    try {
      const r = await fetch(url);
      const gj = await r.json();

      if (!r.ok || gj?.type !== 'FeatureCollection' || !Array.isArray(gj.features)) {
        console.error('Routing response:', gj);
        setMsg('Routing error: ' + (gj?.message || gj?.error || r.status));
        return;
      }

      routeLayer = L.geoJSON(gj, { style: { color:'#0066ff', weight:4, opacity:0.9 } }).addTo(map);
      map.fitBounds(routeLayer.getBounds(), { padding:[20,20] });
      setMsg(`Route drawn · A: ${zoneA} · B: ${zoneB}`);
    } catch (e) {
      console.error(e);
      setMsg('Routing error (see console)');
    }
  }

  async function toLatLng(text){
    // Accept "lat,lng"
    const m = text.match(/^\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/);
    if (m) return { lat: parseFloat(m[1]), lng: parseFloat(m[3]) };

    // Geoapify geocoding, biased to US/WI to avoid odd matches
    const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(text)}&limit=1&filter=countrycode:us|statecode:wi&apiKey=${GEOAPIFY_KEY}`;
    const r = await fetch(url); if (!r.ok) return null;
    const j = await r.json();
    const feat = j.features?.[0]; if (!feat) return null;
    const [lon, lat] = feat.geometry.coordinates; // GeoJSON order
    return { lat, lng: lon };
  }

  function clearRoute(){
    if (routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
    markers.forEach(m => map.removeLayer(m)); markers = [];
    setMsg('');
  }
  </script>
</body>
</html>
